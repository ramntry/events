1. [SOLVED] По всей видимости, необходима не только возможность получить в
обработчике из экземпляра события его отправителя, но и его регистратора.
Либо нужен механизм явного указания receiver'а события. В последнем
случае очевидны как минимум 3 различные стратегии обработки события:
    1. Выполняется поиск обработчика только у receiver'а
    2. Поиск начинается с receiver'а и продолжается обычным образом
       согласно иерархии
    3. Поиск выполняется сначала у receiver'а, а затем стартует с
       отправителя обычным образом за тем исключением, что пропускается
       receiver
Собственно, конечная цель - позволить легко разрешать ситуации подобные
следующей:
    Базовый класс Car предоставляет простой обработчик BeepBeepHandler,
который должен от имени производного класса осуществить звуковой сигнал.
Предполагается, что производный класс связывает некоторое событие, свое
или генерируемое любой своей частью (колесом или двигателем, например),
с этим обработчиком. Таким образом сам обработчик может расчитывать на то,
что найдет в поле sender события указатель на, собственно, колесо или
двигатель. Как найти сам автомобиль? Обращение по parent-указателю решение
не гибкое, поскольку заранее неизвестен уровень вложенности объектов
(например, то же колесо может иметь родителем не автомобиль, а член этого
класса, например, трансмиссию (или что-то еще).

[SOLUTION] Как несложно было понять, проблема родственна другой, еще
не оговоренной - из обработчика события невозможно было получить доступ
к объекту, содержащему этот обработчик. Обойти это можно было либо
сделав обработчик членом класса объекта-receiver'а события, усложнив
таким образом организацию хранения указателей на обработчики, либо
придумать механизм передачи указателя на receiver'а в момент регистрации
обработчика - все это усложнило бы код, а первый вариант и вовсе снизил
бы гибкость происходящего - обработчик был бы обязан быть членом класса
receiver'а, что вообще говоря, совершенно не обязательно с точки зрения
логики клиентского кода. Так что было сделано проще - теперь событие
знает не только своего отправителя, но и приемника - первоначально он
совпадает с отправителем, очевидно, а затем метод send, принимая решение
делегировать событие родителю текущего объекта в иерархии, перед передачей
события по цепочке вверх меняет в нем приемника. Так любой обработчик
получает возможность обратиться к текущему receiver'у.

2. [SOLVED] Шаблонный метод события sender требует указания типа, к которому
выполняется вынужденный (есть сомненния, что от него вообще возможно
избавиться) dynamic_cast. Если программист ошибается, указывая этот тип,
метод возвращает нулевой указатель. Нехорошо возлагать очевидную проверку
на клиента класса. Более того, следует подумать о том, как организовать
удобную возможность варьировать локигу обработчика в зависимости
от типа отправителя события - в идеале с учетом иерархии наследования.

[SOLUTION] В класс Object были добавлены шаблонные методы преобразования
самого себя в желаемый тип безопасным (с выбросом исключения в случае
неудачи) и небезопасным (без проверки результата на ноль) образом. Затем
у класса события были обновлены getter'ы отправителя и получателя - теперь
они используют безопасное преобразование - и добавлены методы tryGetSender
и tryGetReceiver, которые используют небезопасное преобразование -
предполагается, что клиентский код сам будет осуществлять проверку
возвращаемого указателя на ноль.

3. На данный момент методы post и send расчитывают на то, что экземпляр
события будет создан в динамической памяти, а в качестве параметра
конструктору будет передан именно this - и ничто иное. Возможно, стоит
избавить клиентский код от ответственности за выполнение этих условий и
реализовать post и send как шаблонные методы с пустым списком аргументов,
выполняя описанные обязательства в реализациях методов.
